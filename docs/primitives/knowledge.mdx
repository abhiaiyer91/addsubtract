---
title: "Knowledge Primitive"
description: "Content-addressable key-value store backed by Git"
---

# Knowledge Primitive

The Knowledge primitive provides a persistent, versioned key-value store backed by Git objects. Perfect for storing agent facts, preferences, learned information, and configuration.

## Quick Start

```typescript
import { Knowledge } from 'wit/primitives';

// Create a knowledge store
const knowledge = new Knowledge('./agent-memory');

// Store any JSON-serializable value
await knowledge.set('user-prefs', { theme: 'dark', lang: 'typescript' });

// Retrieve by key
const prefs = await knowledge.get('user-prefs');

// Check existence
const exists = await knowledge.has('user-prefs');

// Delete
await knowledge.delete('user-prefs');
```

## Creating a Knowledge Store

```typescript
import { Knowledge } from 'wit/primitives';

// Basic usage
const knowledge = new Knowledge('./my-knowledge');

// With options
const knowledge = new Knowledge('./my-knowledge', {
  autoCommit: true,  // Commit after each change (default: true)
});
```

### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `autoCommit` | boolean | true | Automatically commit after each change |

## Basic Operations

### Set a Value

```typescript
// Store any JSON-serializable value
await knowledge.set('config', {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
});

// Returns the content hash
const hash = await knowledge.set('counter', { count: 0 });
console.log(hash); // 'abc123...'
```

### Get a Value

```typescript
// Get with optional default value
const config = await knowledge.get<Config>('config');
const theme = await knowledge.get('theme', { mode: 'light' });

// Returns undefined if key doesn't exist (and no default)
const missing = await knowledge.get('nonexistent');
```

### Check Existence

```typescript
if (await knowledge.has('user-prefs')) {
  console.log('User has set preferences');
}
```

### Delete a Key

```typescript
// Returns true if key existed
const deleted = await knowledge.delete('temporary-data');
```

### List All Keys

```typescript
const keys = await knowledge.keys();
console.log(keys); // ['config', 'user-prefs', 'counter']
```

### Get All Entries

```typescript
const entries = await knowledge.entries<any>();
for (const [key, value] of entries) {
  console.log(`${key}:`, value);
}
```

## Atomic Updates

Use `update()` to atomically read and modify a value:

```typescript
// Increment a counter
await knowledge.update('counter', (current) => ({
  count: (current?.count || 0) + 1,
}));

// Append to an array
await knowledge.update('logs', (current) => ({
  entries: [...(current?.entries || []), 'New log entry'],
}));

// Merge objects
await knowledge.update('settings', (current) => ({
  ...current,
  lastUpdated: new Date().toISOString(),
}));
```

## Snapshots and History

### Create Snapshots

```typescript
// Create a checkpoint
const snapshot = await knowledge.snapshot('Before experiment');

// Make changes...
await knowledge.set('experimental', { risky: true });

// Restore if something goes wrong
await knowledge.restore(snapshot);
```

### View History

```typescript
// Get history of changes to a key
const history = await knowledge.history<UserPrefs>('user-prefs', 10);

for (const entry of history) {
  console.log(`${entry.timestamp}: ${entry.message}`);
  console.log('  Value:', entry.value);
}
```

### History Entry Structure

```typescript
interface HistoryEntry<T> {
  hash: string;        // Commit hash
  value: T;            // Value at this point
  timestamp: Date;     // When the change was made
  message: string;     // Commit message
}
```

## Clearing All Data

```typescript
// Remove all keys
await knowledge.clear();
```

## Complete Example

```typescript
import { Knowledge } from 'wit/primitives';

interface UserProfile {
  name: string;
  email: string;
  preferences: {
    theme: 'light' | 'dark';
    notifications: boolean;
  };
}

interface ConversationSummary {
  date: string;
  topics: string[];
  sentiment: 'positive' | 'neutral' | 'negative';
  decisions: string[];
}

async function agentMemory() {
  const memory = new Knowledge('./agent-memory');
  
  // Store user profile
  await memory.set<UserProfile>('user-profile', {
    name: 'Alice',
    email: 'alice@example.com',
    preferences: {
      theme: 'dark',
      notifications: true,
    },
  });
  
  // Store conversation summaries
  const today = new Date().toISOString().split('T')[0];
  await memory.set<ConversationSummary>(`conversation-${today}`, {
    date: today,
    topics: ['project planning', 'architecture decisions'],
    sentiment: 'positive',
    decisions: [
      'Use TypeScript',
      'Deploy on AWS',
      'Weekly standup on Monday',
    ],
  });
  
  // Create a snapshot before trying something
  const checkpoint = await memory.snapshot('Before experiment');
  
  // Try an experiment
  try {
    await memory.set('experimental-feature', { enabled: true });
    // ... if this fails ...
    throw new Error('Experiment failed');
  } catch (error) {
    // Restore to checkpoint
    await memory.restore(checkpoint);
  }
  
  // Increment interaction counter
  await memory.update('stats', (current) => ({
    interactions: (current?.interactions || 0) + 1,
    lastInteraction: new Date().toISOString(),
  }));
  
  // Get all stored knowledge
  const allKeys = await memory.keys();
  console.log('Stored knowledge:', allKeys);
  
  // Get recent preference history
  const history = await memory.history<UserProfile>('user-profile', 5);
  console.log('Preference changes:', history.length);
}

agentMemory();
```

## AI Agent Integration

### Long-Term Memory

```typescript
import { Knowledge } from 'wit/primitives';

class AgentMemory {
  private knowledge: Knowledge;
  
  constructor(dir: string) {
    this.knowledge = new Knowledge(dir);
  }
  
  async remember(key: string, value: any): Promise<void> {
    await this.knowledge.set(key, {
      value,
      timestamp: new Date().toISOString(),
    });
  }
  
  async recall(key: string): Promise<any> {
    const entry = await this.knowledge.get<any>(key);
    return entry?.value;
  }
  
  async learnFact(fact: string, category: string): Promise<void> {
    await this.knowledge.update(`facts-${category}`, (current) => ({
      facts: [...(current?.facts || []), fact],
      updated: new Date().toISOString(),
    }));
  }
  
  async getFacts(category: string): Promise<string[]> {
    const entry = await this.knowledge.get<any>(`facts-${category}`);
    return entry?.facts || [];
  }
}

// Usage
const memory = new AgentMemory('./agent-memory');

await memory.remember('user-preference', 'prefers TypeScript');
await memory.learnFact('TypeScript is a superset of JavaScript', 'programming');

const preference = await memory.recall('user-preference');
const facts = await memory.getFacts('programming');
```

### Conversation History

```typescript
import { Knowledge } from 'wit/primitives';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

interface Conversation {
  id: string;
  messages: Message[];
  summary?: string;
}

const conversations = new Knowledge('./conversations');

// Save a conversation
await conversations.set<Conversation>('conv-123', {
  id: '123',
  messages: [
    { role: 'user', content: 'Hello!', timestamp: '2024-01-15T10:00:00Z' },
    { role: 'assistant', content: 'Hi there!', timestamp: '2024-01-15T10:00:01Z' },
  ],
});

// Add a message
await conversations.update<Conversation>('conv-123', (current) => ({
  ...current!,
  messages: [
    ...current!.messages,
    { role: 'user', content: 'How are you?', timestamp: '2024-01-15T10:01:00Z' },
  ],
}));
```

## Type Definitions

```typescript
interface KnowledgeOptions {
  autoCommit?: boolean;  // Default: true
}

interface HistoryEntry<T> {
  hash: string;
  value: T;
  timestamp: Date;
  message: string;
}
```

## Key Validation

Keys must be:
- Non-empty strings
- Maximum 200 characters

```typescript
// Valid keys
await knowledge.set('user-prefs', value);
await knowledge.set('conversation-2024-01-15', value);
await knowledge.set('settings.theme', value);

// Invalid keys (will throw)
await knowledge.set('', value);              // Empty
await knowledge.set('x'.repeat(201), value); // Too long
```

## Storage Details

Knowledge uses Git's content-addressable storage:

1. Values are JSON-serialized
2. Stored as Git blob objects
3. Key→hash mappings stored in a manifest file
4. Auto-committed after each change (if enabled)

```
agent-memory/
├── .wit/
│   └── objects/
│       └── ab/
│           └── c123...  (blob containing JSON value)
└── .knowledge-manifest.json  (key→hash mappings)
```

## Best Practices

<Tip>
**Use descriptive keys**: Organize keys by category, e.g., `user-prefs`, `conversation-2024-01-15`, `fact-typescript`.
</Tip>

<Tip>
**Snapshot before risky operations**: Always create a checkpoint before making experimental changes.
</Tip>

<Tip>
**Use typed access**: Define interfaces for your values and use generic methods for type safety.
</Tip>

<Tip>
**Atomic updates**: Use `update()` instead of `get()` + `set()` for concurrent-safe modifications.
</Tip>

## Next Steps

<CardGroup cols={2}>
  <Card title="Filesystem" icon="folder" href="/primitives/filesystem">
    Git-backed file operations
  </Card>
  <Card title="Primitives Overview" icon="cubes" href="/primitives/overview">
    Learn about all primitives
  </Card>
</CardGroup>
